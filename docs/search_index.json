[["index.html", "Aaron’s Bioinformatics Notes 1 Preamble", " Aaron’s Bioinformatics Notes Aaron Oliver 2023-07-26 1 Preamble Welcome, this is a collection of different standardized genomic analysis pipelines that I often use. In celebration of SIO-BUG’s 2023 revival, I’ve decided to pretty these code notebooks up and make them accessible to everyone in the SIO community. Each page is dedicated to one analysis and includes detailed documentation about each software program that I use, reasons why I’ve chosen it over alternatives, the exact commands that I use, and answers to some previously asked questions. I will not go into detail about how to install each program that I mention. I’ll instead link appropriate conda packages or KBase modules when available. I might also throw in a conda tutorial at some point, depending on how busy I get. Small blurb about myself: I am a 3rd year marine biology student in Eric Allen’s lab at SIO. Before that, I worked as an undergraduate bioinformatics researcher for 3 years and taught as an instructional assistant in the UCSD Computer Science department for 2 years. I got my bachelors in bioinformatics in 2021. "],["cultured-genome-assembly.html", "2 Cultured Genome Assembly 2.1 Short read assembly 2.2 Long read assembly 2.3 Assembly assessment 2.4 Summary", " 2 Cultured Genome Assembly talk about the differences between short and long read assembly 2.1 Short read assembly 2.1.1 Quality control 2.1.2 Trimming 2.1.3 Taxonomic assessment 2.1.4 Running the assembler ln -s assembly/assembly.fasta best_assembly.fasta 2.2 Long read assembly Long read (PacBio and ONT) assembly uses a different suite of tools due to differences in assembly methods and datatypes. 2.2.1 Quality control LongQC Long re python longQC.py sampleqc -x [sequencer] -o qc_output raw_reads.fq where the sequencer can be one of the following: pb-rs2, pb-sequel, pb-hifi, ont-ligation (PromethION), or ont-rapid (MinION, GridION, Flongle). 2.2.2 Taxonomic assessment This step is more time consuming for long reads than short reads. So, I would recommend skipping this step and only coming back here 2.2.3 Running the assembler There are many valid choices of assembler for long reads. Among the most popular and best validated are Flye (ONT/PacBio), Canu (ONT/PacBio), miniasm (ONT/PacBio), Raven (ONT/PacBio), Falcon (PacBio), and the hybrid (Illumina + ONT/PacBio) assemblers Unicycler and hybridSPAdes. Each assembler comes with different usecases and drawbacks. For example, Canu is very slow and Falcon can only use PacBio reads, but both are diploid-aware assemblers which might be critical for certain use cases. Hybrid assembly can work well when single nucleotide differences are important, such as when a strain-level reference genome is available. I will use Flye for this tutorial, since it also has a metagenomic mode for long read MAG binning. So once you are comfortable using Flye for genomes, you can use it for metagenomes too! flye [sequence-type] --genome-size [] raw_reads.fq --out-dir assembly where the sequence type is one of --pacbio-raw, --pacbio-hifi, --nano-raw, or --nano-hq. Estimating genome size based on a quick skim of closest relatives can give you a better assembly, but its optional. The estimated genome size can be formatted in Megabases or Gigabases, e.g. 200m or 3.6g. The CPU parameter for flye is --threads. The output assembly will be located in assembly/assembly.fasta. 2.2.4 Polishing There are also many polishers to be used with long read data. For ONT sequencing, Oxford Nanopore’s own Medaka polisher [Github, Conda] works well, is very fast, and can polish using the same reads input into the assembly. Since Medaka is specifically built to work best with Flye, we will use it for this tutorial. To run Medaka: medaka_consensus -i raw_reads.fq -d assembly/assembly.fasta -o medaka_polished -m [model] See here for more information about how to choose the appropriate model. Your results will be better if you carefully choose the right model, but the program should also work if you just provide r941_min_fast_g303 for MinION/GridION or r941_prom_hac_g303 for high accuracy PrometION data. The CPU parameter for medaka is -t. Your new polished assembly will be located in medaka_polished/consensus.fasta. For consistency with the short read tutorial for the steps below, I am going to create a symbolic link to our best assembly that we will use for the assembly assessment steps. ln -s medaka_polished/consensus.fasta best_assembly.fasta For PacBio data, I suggest polishing with Racon . 2.3 Assembly assessment QUAST [Github, Conda] will give ./quast.py test_data/contigs_1.fasta test_data/contigs_2.fasta -r test_data/reference.fasta.gz -g test_data/genes.txt -1 test_data/reads1.fastq.gz -2 test_data/reads2.fastq.gz -o quast_test_output quast.py best_assembly.fasta -o quast_output This command will provide a set of summary files that you can use to evaluate your assembly. In particular, the N50, number of contigs, total length of all contigs, and the length of the largest contig are all important metrics that are often reported with genome assemblies. The N50 is the length of a contig, such that all the contigs of at least the same length together cover at least 50% of the assembly. While assembly metrics are important, what you will more often be interested in is the level of completeness and contamination in your assembled genome. Which tool you use will depend on what kind of genome you are assembling. The final output of these tools provide completeness (what percentage of expected marker genes were detected) and contamination (what percentage of expected marker genes were detected more than once). A threshold of 50% completeness and 10% contamination is considered a medium-quality genome, and 90% completeness and 5% contamination is necessary (but not sufficient) to have a high-quality genome. 2.3.1 Prokaryotic genome CheckM used to be the gold standard for bacterial completeness analysis. After nine years, CheckM2 has released in 2023, so we now have a new state of the art. CheckM2 has a simple command to generate completeness metrics for you. checkm2 predict --input best_assembly.fasta --output-directory checkm2 CheckM will automatically determine the lineage of our genome and then select a suite of single-copy marker genes relevant to that taxonomic group. --threads is the parameter for CPUs. 2.3.2 Eukaryotic genome BUSCO is an alternative completeness analysis tool with the added benefit of working with both prokaryotic and eukaryotic lineages. In general, I recommend using BUSCO primarily for eukaryotic assemblies, and only using it for prokaryotic assemblies as a point of comparison to CheckM2. To use BUSCO, you will first have to find the lineage closest to your genome in the list of available BUSCO lineages. For example, if you had a diatom genome, the best lineage would be stramenopiles_odb10. If you are unsure of your genome’s lineage, you can run BUSCO’s automated lineage selection by omitting the -l parameter, but it is slow and does not work as well with eukaryotes. busco -i best_assembly.fasta -l [LINEAGE] -o busco -m [MODE] The mode parameter -m should be one of genome, proteins, or transcriptome, depending on your data set. The output file busco/short_summary.txt will provide completeness and contamination metrics. 2.3.3 Viral genome You may still want to do this step, even if you didn’t set out to assemble a viral genome! There is already a nice protocol/tutorial that I use for this step, so I’m just going to link it here! 2.4 Summary Here is the data you have generated up until this point: Quality control metrics on your reads A taxonomic distribution of your reads Cleaned reads with adapters and low quality sequences removed An assembled genome Assembly statistics describing how well your genome assembled Completeness and contamination statistics for your genome Now, you’ll need to annotate your genome to understand its metabolic capacities, perform phylogenetics, and detect novel proteins. Lucky for you, such a tutorial is available in the next chapter! "],["genome-annotation.html", "3 Genome Annotation 3.1 Building gene models 3.2 Annotating proteins", " 3 Genome Annotation 3.1 Building gene models 3.1.1 Prokaryotes 3.1.2 Eukaryotes 3.2 Annotating proteins "],["metaG.html", "4 Metagenomic Assembly and Binning 4.1 Exploring the bins", " 4 Metagenomic Assembly and Binning 4.1 Exploring the bins 4.1.1 Bin completeness and quality metrics Depending on which metagenomic binner you choose, this step might already be done for you. When assessing the quality of a single bin, there are two source of data you want to analyze: completeness and contamination (CheckM2) and assembly statistics (Quast). 4.1.2 Assess genome taxonomy To assess genomic novelty and get the closest relatives at the nucleotide level, we can use the Genome Taxonomy Database Toolkit (Chaumeil et al. 2020). GTDB-Tk will accept a set of assembled or binned prokaryotic genomes, and provide a predicted phylogenetic lineage, the closest known relative, and a distance metric (average nucleotide identity) to that relative. gtdbtk classify_wf --genome_dir bins --out_dir gtdb-tk Other useful parameters include the file extension of metagenomic bins in your bin folder (–x), and the number of CPUs (–cpu). As an example, if your folder was full of .fna (“fasta nucleic acid”) files, and you wanted to use 8 CPUs, you could use the command: gtdbtk classify_wf --genome_dir bins --out_dir gtdb-tk --x fna --cpu 8 Keep in mind that the GTDB (Parks et al. 2022) can diverge in taxonomic names from other resources such as NCBI, so you should try to be consistent in what naming system you will use throughout your project. References "],["references.html", "References", " References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
